"use strict";

const moment = use("moment");
const Helpers = use("Helpers");
const Database = use("Database");
const chunk = use("lodash/chunk");
const { Command } = use("@adonisjs/ace");

class RunDataMigration extends Command {
  /**
   * Signature of the console command.
   *
   * @returns {String}
   */
  static get signature() {
    return "data-migration:run";
  }

  /**
   * Description of the console command.
   *
   * @returns {String}
   */
  static get description() {
    return "Run all pending data migrations";
  }

  static get migrationPath() {
    return Helpers.databasePath("data-migrations/");
  }

  /**
   * Execute the console command.
   *
   * @param {Object} args
   * @param {Object} options
   * @returns {Promise}
   */
  async handle(args, options) {
    const startTime = moment();
    this.migrationCount = 0;
    const files = await this.getFiles();
    const lastBatch = await Database.table("data_migrations").max("batch as batchNo");
    this.currentBatch = lastBatch[0].batchNo ? lastBatch[0].batchNo + 1 : 1;
    for (var file of files) {
      let migration = await this.migrateFile(file);
    }
    Database.close();
    const endTime = moment();
    const totalTime = moment.duration(endTime.diff(startTime)).asMilliseconds() + " ms";
    if (this.migrationCount > 0) {
      this.success(`${this.icon("success")} Data migrated successfully in ${totalTime}`);
    } else {
      this.info(`Nothing to migrate`);
    }
  }

  /**
   * Get list of migration iles
   */
  getFiles() {
    return new Promise(resolve => {
      const fs = require("fs");
      const files = fs.readdir(RunDataMigration.migrationPath, (err, files) => {
        if (err) {
          resolve([]);
        }
        resolve(files);
      });
    });
  }

  async migrateFile(fileName) {
    const file = require(RunDataMigration.migrationPath + fileName);
    const ticketChunks = chunk(Object.keys(file), 50);
    try {
      await this.createTempTable();
      for (var tickets of ticketChunks) {
        const insertData = tickets.map(ticket => {
          return { name: ticket };
        });
        await Database.insert(insertData).into("temp_data_migrations");
      }
      const ticketToMigrate = await Database.table("temp_data_migrations")
        .whereNotIn("name", builder => {
          builder
            .select("name")
            .from("data_migrations")
            .where("file", fileName);
        })
        .pluck("name");
      if (ticketToMigrate.length) {
        for (var ticketName of ticketToMigrate) {
          var queries = file[ticketName];
          for (var query of queries) {
            await Database.raw(query);
            this.migrationCount++;
          }
          await Database.insert({
            file: fileName,
            name: ticketName,
            batch: this.currentBatch
          }).into("data_migrations");
        }
      }
    } catch (e) {
      console.log(e);
    } finally {
      await this.dropTempTable();
    }
  }

  async createTempTable() {
    await Database.raw(`Create table if not exists temp_data_migrations (
      name VARCHAR(255),
      UNIQUE KEY temp_data_migrations_unique (name)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8`);
  }

  async dropTempTable() {
    await Database.raw(`Drop table if exists temp_data_migrations`);
  }
}

module.exports = RunDataMigration;
